package controller

import (
	"context"
	"fmt"
	"math/rand"
	"sort"
	"strings"
	"time"

	"github.com/pluralsh/deployment-operator/pkg/common"
	smcommon "github.com/pluralsh/deployment-operator/pkg/streamline/common"

	"github.com/aquasecurity/trivy-db/pkg/types"
	trivy "github.com/aquasecurity/trivy-operator/pkg/apis/aquasecurity/v1alpha1"
	cmap "github.com/orcaman/concurrent-map/v2"
	console "github.com/pluralsh/console/go/client"
	"github.com/samber/lo"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
	ctrl "sigs.k8s.io/controller-runtime"
	k8sClient "sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/log"

	"github.com/pluralsh/deployment-operator/internal/helpers"
	"github.com/pluralsh/deployment-operator/pkg/client"
)

const (

	// reportUploadInterval defines the time interval between successive report uploads.
	reportUploadInterval = 60 * time.Minute

	// vulnerabilityRequeueAfter defines the duration to wait before requeueing a vulnerability for processing.
	vulnerabilityRequeueAfter = 6 * time.Minute

	// vulnerabilityJitter defines the random jitter duration added to vulnerability processing to prevent synchronized operations.
	vulnerabilityJitter = 10 * time.Minute

	reportChunkSize = 15
)

// VulnerabilityReportReconciler reconciles a Trivy VulnerabilityReport resource.
type VulnerabilityReportReconciler struct {
	k8sClient.Client
	Scheme        *runtime.Scheme
	ConsoleClient client.Client
	Ctx           context.Context
	reports       cmap.ConcurrentMap[string, vulnReport]
}

func (r *VulnerabilityReportReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) {
	logger := log.FromContext(ctx)

	vulnerabilityReport := &trivy.VulnerabilityReport{}
	if err := r.Get(ctx, req.NamespacedName, vulnerabilityReport); err != nil {
		logger.Error(err, "unable to fetch vulnerability report")
		return ctrl.Result{}, k8sClient.IgnoreNotFound(err)
	}

	if !vulnerabilityReport.DeletionTimestamp.IsZero() {
		r.reports.Remove(req.String())
		return ctrl.Result{}, nil
	}

	var serviceId *string
	if len(vulnerabilityReport.OwnerReferences) > 0 {
		k8sObj, err := GetObjectFromOwnerReference(ctx, r.Client, vulnerabilityReport.OwnerReferences[0], vulnerabilityReport.Namespace)
		if err != nil {
			return ctrl.Result{}, err
		}
		svcId, ok := k8sObj.GetAnnotations()[smcommon.OwningInventoryKey]
		if ok {
			serviceId = lo.ToPtr(svcId)
		}
	}
	attrs, timestamp := createVulnAttributes(*vulnerabilityReport, serviceId)
	r.reports.Set(req.String(), vulnReport{
		attributes: &attrs,
		timestamp:  timestamp,
	})

	// Scheduled jitterRequeue allows us to rebuild the vulnerability reports map from time to time in order to
	// allow map elements to be eventually garbage collected
	return jitterRequeue(vulnerabilityRequeueAfter, vulnerabilityJitter), nil
}

func createVulnAttributes(vulnerabilityReport trivy.VulnerabilityReport, serviceID *string) (console.VulnerabilityReportAttributes, time.Time) {
	var namespaces []*console.NamespaceVulnAttributes
	os := &console.VulnOsAttributes{
		Eosl:   lo.ToPtr(vulnerabilityReport.Report.OS.Eosl),
		Family: lo.ToPtr(string(vulnerabilityReport.Report.OS.Family)),
		Name:   lo.ToPtr(vulnerabilityReport.Report.OS.Name),
	}
	summary := &console.VulnSummaryAttributes{
		CriticalCount: lo.ToPtr(int64(vulnerabilityReport.Report.Summary.CriticalCount)),
		HighCount:     lo.ToPtr(int64(vulnerabilityReport.Report.Summary.HighCount)),
		MediumCount:   lo.ToPtr(int64(vulnerabilityReport.Report.Summary.MediumCount)),
		LowCount:      lo.ToPtr(int64(vulnerabilityReport.Report.Summary.LowCount)),
		UnknownCount:  lo.ToPtr(int64(vulnerabilityReport.Report.Summary.UnknownCount)),
		NoneCount:     lo.ToPtr(int64(vulnerabilityReport.Report.Summary.NoneCount)),
	}
	artifact := &console.VulnArtifactAttributes{
		Registry:   lo.ToPtr(vulnerabilityReport.Report.Registry.Server),
		Repository: lo.ToPtr(vulnerabilityReport.Report.Artifact.Repository),
		Digest:     lo.ToPtr(vulnerabilityReport.Report.Artifact.Digest),
		Tag:        lo.ToPtr(vulnerabilityReport.Report.Artifact.Tag),
		Mime:       lo.ToPtr(vulnerabilityReport.Report.Artifact.MimeType),
	}
	format := "%s/%s:%s"
	tag := vulnerabilityReport.Report.Artifact.Tag
	if tag == "" {
		tag = vulnerabilityReport.Report.Artifact.Digest
		format = "%s/%s@%s"
	}
	artifactURL := fmt.Sprintf(format, vulnerabilityReport.Report.Registry.Server, vulnerabilityReport.Report.Artifact.Repository, tag)
	services := make([]*console.ServiceVulnAttributes, 0, lo.Ternary(serviceID != nil, 1, 0))
	if serviceID != nil {
		services = append(services, &console.ServiceVulnAttributes{
			ServiceID: *serviceID,
		})
	}

	if vulnerabilityReport.Namespace != "" {
		namespaces = []*console.NamespaceVulnAttributes{
			{
				Namespace: vulnerabilityReport.Namespace,
			},
		}
	}

	vulnerabilityAttributes := make([]*console.VulnerabilityAttributes, 0, len(vulnerabilityReport.Report.Vulnerabilities))
	for _, v := range vulnerabilityReport.Report.Vulnerabilities {
		vulnerabilityAttr := &console.VulnerabilityAttributes{
			Resource:         lo.ToPtr(v.Resource),
			FixedVersion:     lo.ToPtr(v.FixedVersion),
			InstalledVersion: lo.ToPtr(v.InstalledVersion),
			Severity:         lo.ToPtr(console.VulnSeverity(v.Severity)),
			Score:            v.Score,
			Title:            lo.ToPtr(v.Title),
			Description:      lo.ToPtr(v.Description),
			Cvss:             parseCvss(v.CVSS),
			CvssSource:       lo.ToPtr(v.CVSSSource),
			PrimaryLink:      lo.ToPtr(v.PrimaryLink),
			Links:            lo.ToSlicePtr(v.Links),
			Target:           lo.ToPtr(v.Target),
			Class:            lo.ToPtr(v.Class),
			PackageType:      lo.ToPtr(v.PackageType),
			PkgPath:          lo.ToPtr(v.PkgPath),
		}
		if v.PublishedDate != "" {
			vulnerabilityAttr.PublishedDate = lo.ToPtr(v.PublishedDate)
		}
		if v.LastModifiedDate != "" {
			vulnerabilityAttr.LastModifiedDate = lo.ToPtr(v.LastModifiedDate)
		}
		vulnerabilityAttributes = append(vulnerabilityAttributes, vulnerabilityAttr)
	}

	return console.VulnerabilityReportAttributes{
		ArtifactURL:     lo.ToPtr(artifactURL),
		Os:              os,
		Summary:         summary,
		Artifact:        artifact,
		Vulnerabilities: vulnerabilityAttributes,
		Services:        services,
		Namespaces:      namespaces,
	}, vulnerabilityReport.CreationTimestamp.Time
}

func parseCvss(cvss types.VendorCVSS) *console.CvssBundleAttributes {
	result := &console.CvssBundleAttributes{}
	if cvss == nil {
		return result
	}

	if nvidia, ok := cvss["nvidia"]; ok {
		result.Nvidia = &console.CvssAttributes{
			V3Vector: lo.ToPtr(nvidia.V3Vector),
			V3Score:  lo.ToPtr(nvidia.V3Score),
		}
	}

	if redhat, ok := cvss["redhat"]; ok {
		result.Redhat = &console.CvssAttributes{
			V3Vector: lo.ToPtr(redhat.V3Vector),
			V3Score:  lo.ToPtr(redhat.V3Score),
		}
	}

	return result
}

func (r *VulnerabilityReportReconciler) SetupWithManager(mgr ctrl.Manager) error {
	logger := log.FromContext(r.Ctx)
	r.reports = cmap.New[vulnReport]()

	interval := func() time.Duration {
		if vulnerabilityReportUploadInterval := common.GetConfigurationManager().GetCompatibilityUploadInterval(); vulnerabilityReportUploadInterval != nil {
			return *vulnerabilityReportUploadInterval
		}

		return reportUploadInterval
	}

	err := helpers.DynamicBackgroundPollUntilContextCancel(r.Ctx, interval, false, func(_ context.Context) (done bool, err error) {
		if !r.reports.IsEmpty() {
			items := r.reports.Items()
			sortedItems := lo.Values(items)
			sort.Slice(sortedItems, func(i, j int) bool {
				return sortedItems[i].timestamp.After(sortedItems[j].timestamp)
			})

			reportsByArtifact := make(map[string]*aggregateReport)
			for _, report := range sortedItems {
				if report.attributes.ArtifactURL == nil {
					continue
				}
				url := *report.attributes.ArtifactURL

				if agg, exists := reportsByArtifact[url]; exists {
					agg.addReport(report.attributes)
				} else {
					reportsByArtifact[url] = newAggregateReport(report.attributes, report.timestamp)
				}
			}

			apiReports := lo.Map(lo.Values(reportsByArtifact), func(report *aggregateReport, _ int) *console.VulnerabilityReportAttributes {
				return report.toVulnerabilityReport()
			})

			for _, chunk := range lo.Chunk(apiReports, reportChunkSize) {
				if _, err := r.ConsoleClient.UpsertVulnerabilityReports(chunk); err != nil {
					logger.Error(err, "unable to upsert vulnerability reports")
				} else {
					r.reports.Clear()
					r.reports = cmap.New[vulnReport]()
					logger.Info("upsert vulnerability reports")
				}

				time.Sleep(time.Duration(rand.Int63n(int64(500 * time.Millisecond))))
			}
		}
		return false, nil
	})
	if err != nil {
		return err
	}

	return ctrl.NewControllerManagedBy(mgr).
		For(&trivy.VulnerabilityReport{}).
		Complete(r)
}

// aggregateReport holds the aggregated data for a single artifact URL
type aggregateReport struct {
	base       *console.VulnerabilityReportAttributes
	services   map[string]*console.ServiceVulnAttributes
	namespaces map[string]*console.NamespaceVulnAttributes
	timestamp  time.Time // Adding timestamp for sorting
}

// vulnReport holds the vulnerability report data along with sorting information
type vulnReport struct {
	attributes *console.VulnerabilityReportAttributes
	timestamp  time.Time
}

// newAggregateReport creates a new aggregateReport from a vulnerability report
func newAggregateReport(report *console.VulnerabilityReportAttributes, timestamp time.Time) *aggregateReport {
	agg := &aggregateReport{
		base:       report,
		services:   make(map[string]*console.ServiceVulnAttributes, len(report.Services)),
		namespaces: make(map[string]*console.NamespaceVulnAttributes, len(report.Namespaces)),
		timestamp:  timestamp,
	}

	for _, svc := range report.Services {
		if svc != nil {
			agg.services[svc.ServiceID] = svc
		}
	}

	for _, ns := range report.Namespaces {
		if ns != nil {
			agg.namespaces[ns.Namespace] = ns
		}
	}

	return agg
}

// addReport merges another report into this aggregate
func (a *aggregateReport) addReport(report *console.VulnerabilityReportAttributes) {
	for _, svc := range report.Services {
		if svc != nil {
			a.services[svc.ServiceID] = svc
		}
	}

	for _, ns := range report.Namespaces {
		if ns != nil {
			a.namespaces[ns.Namespace] = ns
		}
	}
}

// toVulnerabilityReport converts the aggregate back to a VulnerabilityReportAttributes
func (a *aggregateReport) toVulnerabilityReport() *console.VulnerabilityReportAttributes {
	services := make([]*console.ServiceVulnAttributes, 0, len(a.services))
	namespaces := make([]*console.NamespaceVulnAttributes, 0, len(a.namespaces))

	svcKeys := make([]string, 0, len(a.services))
	nsKeys := make([]string, 0, len(a.namespaces))

	for k := range a.services {
		svcKeys = append(svcKeys, k)
	}
	for k := range a.namespaces {
		nsKeys = append(nsKeys, k)
	}
	sort.Strings(svcKeys)
	sort.Strings(nsKeys)

	for _, k := range svcKeys {
		services = append(services, a.services[k])
	}
	for _, k := range nsKeys {
		namespaces = append(namespaces, a.namespaces[k])
	}

	result := *a.base
	result.Services = services
	result.Namespaces = namespaces
	return &result
}

func apiVersionToGroupVersion(apiVersion string) (schema.GroupVersion, error) {
	parts := strings.Split(apiVersion, "/")
	if len(parts) == 1 {
		// If there's no group specified, it's the "core" group, e.g., "v1"
		return schema.GroupVersion{Group: "", Version: parts[0]}, nil
	} else if len(parts) == 2 {
		return schema.GroupVersion{Group: parts[0], Version: parts[1]}, nil
	}
	return schema.GroupVersion{}, fmt.Errorf("invalid apiVersion: %s", apiVersion)
}
