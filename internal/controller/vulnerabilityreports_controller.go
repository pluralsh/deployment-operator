package controller

import (
	"context"
	"fmt"
	"math/rand"
	"strings"
	"time"

	"github.com/aquasecurity/trivy-db/pkg/types"
	trivy "github.com/aquasecurity/trivy-operator/pkg/apis/aquasecurity/v1alpha1"
	cmap "github.com/orcaman/concurrent-map/v2"
	console "github.com/pluralsh/console/go/client"
	"github.com/pluralsh/polly/algorithms"
	"github.com/samber/lo"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"sigs.k8s.io/cli-utils/pkg/inventory"
	ctrl "sigs.k8s.io/controller-runtime"
	k8sClient "sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/log"

	"github.com/pluralsh/deployment-operator/internal/helpers"
	"github.com/pluralsh/deployment-operator/pkg/client"
)

const (

	// reportUploadInterval defines the time interval between successive report uploads.
	reportUploadInterval = 10 * time.Minute

	// vulnerabilityRequeueAfter defines the duration to wait before requeueing a vulnerability for processing.
	vulnerabilityRequeueAfter = 6 * time.Minute

	// vulnerabilityJitter defines the random jitter duration added to vulnerability processing to prevent synchronized operations.
	vulnerabilityJitter = 2 * time.Minute

	reportChunkSize = 15
)

// VulnerabilityReportReconciler reconciles a Trivy VulnerabilityReport resource.
type VulnerabilityReportReconciler struct {
	k8sClient.Client
	Scheme        *runtime.Scheme
	ConsoleClient client.Client
	Ctx           context.Context
	reports       cmap.ConcurrentMap[string, console.VulnerabilityReportAttributes]
}

func (r *VulnerabilityReportReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) {
	logger := log.FromContext(ctx)

	vulnerabilityReport := &trivy.VulnerabilityReport{}
	if err := r.Get(ctx, req.NamespacedName, vulnerabilityReport); err != nil {
		logger.Error(err, "unable to fetch vulnerability report")
		return ctrl.Result{}, k8sClient.IgnoreNotFound(err)
	}

	if !vulnerabilityReport.DeletionTimestamp.IsZero() {
		r.reports.Remove(req.String())
		return ctrl.Result{}, nil
	}

	var serviceId *string
	if len(vulnerabilityReport.OwnerReferences) > 0 {
		k8sObj, err := GetObjectFromOwnerReference(ctx, r.Client, vulnerabilityReport.OwnerReferences[0], vulnerabilityReport.Namespace)
		if err != nil {
			return ctrl.Result{}, err
		}
		svcId, ok := k8sObj.GetAnnotations()[inventory.OwningInventoryKey]
		if ok {
			serviceId = lo.ToPtr(svcId)
		}
	}
	r.reports.Set(req.String(), createVulnAttributes(*vulnerabilityReport, serviceId))

	// Scheduled requeue allows us to rebuild the vulnerability reports map from time to time in order to
	// allow map elements to be eventually garbage collected
	return requeue(vulnerabilityRequeueAfter, vulnerabilityJitter), nil
}

func createVulnAttributes(vulnerabilityReport trivy.VulnerabilityReport, serviceID *string) console.VulnerabilityReportAttributes {
	var namespaces []*console.NamespaceVulnAttributes
	os := &console.VulnOsAttributes{
		Eosl:   lo.ToPtr(vulnerabilityReport.Report.OS.Eosl),
		Family: lo.ToPtr(string(vulnerabilityReport.Report.OS.Family)),
		Name:   lo.ToPtr(vulnerabilityReport.Report.OS.Name),
	}
	summary := &console.VulnSummaryAttributes{
		CriticalCount: lo.ToPtr(int64(vulnerabilityReport.Report.Summary.CriticalCount)),
		HighCount:     lo.ToPtr(int64(vulnerabilityReport.Report.Summary.HighCount)),
		MediumCount:   lo.ToPtr(int64(vulnerabilityReport.Report.Summary.MediumCount)),
		LowCount:      lo.ToPtr(int64(vulnerabilityReport.Report.Summary.LowCount)),
		UnknownCount:  lo.ToPtr(int64(vulnerabilityReport.Report.Summary.UnknownCount)),
		NoneCount:     lo.ToPtr(int64(vulnerabilityReport.Report.Summary.NoneCount)),
	}
	artifact := &console.VulnArtifactAttributes{
		Registry:   lo.ToPtr(vulnerabilityReport.Report.Registry.Server),
		Repository: lo.ToPtr(vulnerabilityReport.Report.Artifact.Repository),
		Digest:     lo.ToPtr(vulnerabilityReport.Report.Artifact.Digest),
		Tag:        lo.ToPtr(vulnerabilityReport.Report.Artifact.Tag),
		Mime:       lo.ToPtr(vulnerabilityReport.Report.Artifact.MimeType),
	}
	format := "%s/%s:%s"
	tag := vulnerabilityReport.Report.Artifact.Tag
	if tag == "" {
		tag = vulnerabilityReport.Report.Artifact.Digest
		format = "%s/%s@%s"
	}
	artifactURL := fmt.Sprintf(format, vulnerabilityReport.Report.Registry.Server, vulnerabilityReport.Report.Artifact.Repository, tag)
	services := make([]*console.ServiceVulnAttributes, 0, lo.Ternary(serviceID != nil, 1, 0))
	if serviceID != nil {
		services = append(services, &console.ServiceVulnAttributes{
			ServiceID: *serviceID,
		})
	}

	if vulnerabilityReport.Namespace != "" {
		namespaces = []*console.NamespaceVulnAttributes{
			{
				Namespace: vulnerabilityReport.Namespace,
			},
		}
	}

	vulnerabilityAttributes := make([]*console.VulnerabilityAttributes, 0, len(vulnerabilityReport.Report.Vulnerabilities))
	for _, v := range vulnerabilityReport.Report.Vulnerabilities {
		vulnerabilityAttr := &console.VulnerabilityAttributes{
			Resource:         lo.ToPtr(v.Resource),
			FixedVersion:     lo.ToPtr(v.FixedVersion),
			InstalledVersion: lo.ToPtr(v.InstalledVersion),
			Severity:         lo.ToPtr(console.VulnSeverity(v.Severity)),
			Score:            v.Score,
			Title:            lo.ToPtr(v.Title),
			Description:      lo.ToPtr(v.Description),
			Cvss:             parseCvss(v.CVSS),
			CvssSource:       lo.ToPtr(v.CVSSSource),
			PrimaryLink:      lo.ToPtr(v.PrimaryLink),
			Links:            lo.ToSlicePtr(v.Links),
			Target:           lo.ToPtr(v.Target),
			Class:            lo.ToPtr(v.Class),
			PackageType:      lo.ToPtr(v.PackageType),
			PkgPath:          lo.ToPtr(v.PkgPath),
		}
		if v.PublishedDate != "" {
			vulnerabilityAttr.PublishedDate = lo.ToPtr(v.PublishedDate)
		}
		if v.LastModifiedDate != "" {
			vulnerabilityAttr.LastModifiedDate = lo.ToPtr(v.LastModifiedDate)
		}
		vulnerabilityAttributes = append(vulnerabilityAttributes, vulnerabilityAttr)
	}

	return console.VulnerabilityReportAttributes{
		ArtifactURL:     lo.ToPtr(artifactURL),
		Os:              os,
		Summary:         summary,
		Artifact:        artifact,
		Vulnerabilities: vulnerabilityAttributes,
		Services:        services,
		Namespaces:      namespaces,
	}
}

func parseCvss(cvss types.VendorCVSS) *console.CvssBundleAttributes {
	result := &console.CvssBundleAttributes{}
	if cvss == nil {
		return result
	}

	if nvidia, ok := cvss["nvidia"]; ok {
		result.Nvidia = &console.CvssAttributes{
			V3Vector: lo.ToPtr(nvidia.V3Vector),
			V3Score:  lo.ToPtr(nvidia.V3Score),
		}
	}

	if redhat, ok := cvss["redhat"]; ok {
		result.Redhat = &console.CvssAttributes{
			V3Vector: lo.ToPtr(redhat.V3Vector),
			V3Score:  lo.ToPtr(redhat.V3Score),
		}
	}

	return result
}

func (r *VulnerabilityReportReconciler) SetupWithManager(mgr ctrl.Manager) error {
	logger := log.FromContext(r.Ctx)
	r.reports = cmap.New[console.VulnerabilityReportAttributes]()
	err := helpers.BackgroundPollUntilContextCancel(r.Ctx, reportUploadInterval, false, true, func(_ context.Context) (done bool, err error) {
		if !r.reports.IsEmpty() {
			apiReports := algorithms.Map(lo.Values(r.reports.Items()), func(s console.VulnerabilityReportAttributes) *console.VulnerabilityReportAttributes { return &s })

			for _, chunk := range lo.Chunk(apiReports, reportChunkSize) {
				if _, err := r.ConsoleClient.UpsertVulnerabilityReports(chunk); err != nil {
					logger.Error(err, "unable to upsert vulnerability reports")
				} else {
					// Clear the reports map and allow dangling elements to be garbage collected
					r.reports.Clear()
					r.reports = cmap.New[console.VulnerabilityReportAttributes]()
					logger.Info("upsert vulnerability reports")
				}

				time.Sleep(time.Duration(rand.Int63n(int64(500 * time.Millisecond))))
			}
		}
		return false, nil
	})
	if err != nil {
		return err
	}

	return ctrl.NewControllerManagedBy(mgr).
		For(&trivy.VulnerabilityReport{}).
		Complete(r)
}

func apiVersionToGroupVersion(apiVersion string) (schema.GroupVersion, error) {
	parts := strings.Split(apiVersion, "/")
	if len(parts) == 1 {
		// If there's no group specified, it's the "core" group, e.g., "v1"
		return schema.GroupVersion{Group: "", Version: parts[0]}, nil
	} else if len(parts) == 2 {
		return schema.GroupVersion{Group: parts[0], Version: parts[1]}, nil
	}
	return schema.GroupVersion{}, fmt.Errorf("invalid apiVersion: %s", apiVersion)
}
